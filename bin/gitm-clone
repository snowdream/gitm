#!/usr/bin/env node

var fs = require('fs');
var request = require('sync-request');
var program = require('commander');
var gitm_execute = require('./gitm-execute');

program
    .parse(process.argv);

var args = program.args;


var repo;
if (!args.length) {
    repo = JSON.parse(fs.readFileSync('./repo.gitm'));
} else if (args.length == 1) {
    var res = request('GET', args[0]);
    repo = JSON.parse(res.getBody());
} else {
    console.error('invalid parameters.');
    process.exit(1);
}

console.warn("repo:");
console.warn(repo);

if (!repo) {
    console.warn("The file repo.gitm does not exist.");
    return;
}

if (!repo.repository && !repo.repositories) {
    console.warn("The file repo.gitm is not valid.");
    return;
}

if (repo.repository) {
    clone(repo.repository, __dirname);
} else if (repo.repositories) {
    for (var i = 0, len = repo.repositories.length; i < len; i++) {
        clone(repo.repositories[i], __dirname);
    }
}

function clone(repo, dir) {
    if (!repo) {
        return;
    }

    if (!repo.name) {
        repo.name = getRepoName(repo.url);
    }

    gitm_execute.execSync("git clone " + repo.url + " " + repo.name + " --progress -v");

    if(repo.branches){
        try {
            if (!fs.existsSync(repo.name)) {
                fs.mkdirSync(repo.name);
            }
            process.chdir(repo.name);
        }
        catch (err) {
            console.log('chdir: ' + err);
        }

        for (var len = repo.branches.length, i = len -1; i >= 0; i--) {
            var branch = repo.branches[i];
            if(branch == "master"){
                if(i != 0){
                    continue;
                }
                gitm_execute.execSync("git checkout " + branch);
            }
            gitm_execute.execSync("git checkout origin/" + branch);
            gitm_execute.execSync("git checkout -b " + branch);
            gitm_execute.execSync("git branch --set-upstream "+branch+" origin/" + branch);
        }

        process.chdir(dir.toString());
    }

    if (repo.repositories) {
        try {
            if (!fs.existsSync(repo.name)) {
                fs.mkdirSync(repo.name);
            }
            process.chdir(repo.name);
        }
        catch (err) {
            console.log('chdir: ' + err);
        }

        for (var i = 0, len = repo.repositories.length; i < len; i++) {
            clone(repo.repositories[i]);
        }

        process.chdir(dir.toString());
    }
}

function getRepoName(url) {
    if (!url) {
        return;
    }

    var sep = '/';
    if (!url.match(sep) && !url.match('\\\\')) {
        sep = '/';
    }

    var index = url.lastIndexOf(sep);
    console.warn(url);
    console.warn(index);
    console.warn(url.length - 1);

    if (index == url.length - 1) {
        url = url.substring(0, index)
        index = url.lastIndexOf(sep);
        console.warn(url);
        console.warn(index);
    }

    var name = url.substring(index + 1)
    name= name.replace(/\.git/g, "O")
    console.warn(name);

    return name;
}


function isArray(obj) {
    return Object.prototype.toString.call(obj) == '[object Array]';
}

